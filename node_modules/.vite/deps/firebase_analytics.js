import "./chunk-ILVUQTSR.js";
import {
  Component,
  ErrorFactory,
  FirebaseError,
  Logger,
  _getProvider,
  _registerComponent,
  areCookiesEnabled,
  calculateBackoffMillis,
  deepEqual,
  getApp,
  getModularInstance,
  isBrowserExtension,
  isIndexedDBAvailable,
  registerVersion,
  validateIndexedDBOpenable
} from "./chunk-CRF5B5VF.js";
import {
  __export
} from "./chunk-EWTE5DHJ.js";

// node_modules/safevalues/dist/mjs/environment/dev.js
(() => {
  if (typeof process === "undefined") {
    window.process = {
      env: {
        NODE_ENV: "development"
      }
    };
  }
})();

// node_modules/safevalues/dist/mjs/internals/secrets.js
var secretToken = {};
function ensureTokenIsValid(token) {
  if (true) {
    if (token !== secretToken) {
      throw new Error("Bad secret");
    }
  }
}

// node_modules/safevalues/dist/mjs/internals/attribute_impl.js
var SafeAttributePrefix = class {
  constructor(token, value) {
    if (true) {
      ensureTokenIsValid(token);
    }
    this.privateDoNotAccessOrElseWrappedAttributePrefix = value;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedAttributePrefix;
  }
};
function isAttributePrefix(value) {
  return value instanceof SafeAttributePrefix;
}
function unwrapAttributePrefix(value) {
  if (isAttributePrefix(value)) {
    return value.privateDoNotAccessOrElseWrappedAttributePrefix;
  }
  let message = "";
  if (true) {
    message = `Unexpected type when unwrapping SafeAttributePrefix, got '${value}' of type '${typeof value}'`;
  }
  throw new Error(message);
}

// node_modules/safevalues/dist/mjs/internals/string_literal.js
function assertIsTemplateObject(templateObj, numExprs) {
  if (!isTemplateObject(templateObj) || numExprs + 1 !== templateObj.length) {
    throw new TypeError(`
    ############################## ERROR ##############################

    It looks like you are trying to call a template tag function (fn\`...\`)
    using the normal function syntax (fn(...)), which is not supported.

    The functions in the safevalues library are not designed to be called
    like normal functions, and doing so invalidates the security guarantees
    that safevalues provides.

    If you are stuck and not sure how to proceed, please reach out to us
    instead through:
     - https://github.com/google/safevalues/issues

    ############################## ERROR ##############################`);
  }
}
function checkFrozen(templateObj) {
  return Object.isFrozen(templateObj) && Object.isFrozen(templateObj.raw);
}
function checkTranspiled(fn) {
  return fn.toString().indexOf("`") === -1;
}
var isTranspiled = checkTranspiled((tag) => tag``) || checkTranspiled((tag) => tag`\0`) || checkTranspiled((tag) => tag`\n`) || checkTranspiled((tag) => tag`\u0000`);
var frozenTSA = checkFrozen`` && checkFrozen`\0` && checkFrozen`\n` && checkFrozen`\u0000`;
function isTemplateObject(templateObj) {
  if (!Array.isArray(templateObj) || !Array.isArray(templateObj.raw)) {
    return false;
  }
  if (templateObj.length !== templateObj.raw.length) {
    return false;
  }
  if (!isTranspiled && templateObj === templateObj.raw) {
    return false;
  }
  if ((!isTranspiled || frozenTSA) && !checkFrozen(templateObj)) {
    return false;
  }
  return true;
}

// node_modules/safevalues/dist/mjs/internals/trusted_types.js
var trustedTypesPolicyName = "google#safe";
function trustedTypes() {
  if (typeof window !== "undefined") {
    return window.trustedTypes;
  }
  return void 0;
}
function getTrustedTypes() {
  var _a;
  return trustedTypesPolicyName !== "" ? (_a = trustedTypes()) !== null && _a !== void 0 ? _a : null : null;
}
var trustedTypesPolicy;
function getTrustedTypesPolicy() {
  var _a, _b;
  if (trustedTypesPolicy === void 0) {
    try {
      trustedTypesPolicy = (_b = (_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.createPolicy(trustedTypesPolicyName, {
        createHTML: (s) => s,
        createScript: (s) => s,
        createScriptURL: (s) => s
      })) !== null && _b !== void 0 ? _b : null;
    } catch (_c) {
      trustedTypesPolicy = null;
    }
  }
  return trustedTypesPolicy;
}

// node_modules/safevalues/dist/mjs/internals/html_impl.js
var HtmlImpl = class {
  constructor(html, token) {
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedHtml = html;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedHtml.toString();
  }
};
function createTrustedHtmlOrPolyfill(html, trusted) {
  return trusted !== null && trusted !== void 0 ? trusted : new HtmlImpl(html, secretToken);
}
var GlobalTrustedHTML = typeof window !== "undefined" ? window.TrustedHTML : void 0;
function createHtmlInternal(html) {
  var _a;
  const noinlineHtml = html;
  return createTrustedHtmlOrPolyfill(noinlineHtml, (_a = getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createHTML(noinlineHtml));
}
var EMPTY_HTML = (() => {
  var _a;
  return createTrustedHtmlOrPolyfill("", (_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.emptyHTML);
})();
function unwrapHtml(value) {
  var _a;
  if ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isHTML(value)) {
    return value;
  } else if (value instanceof HtmlImpl) {
    return value.privateDoNotAccessOrElseWrappedHtml;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping SafeHtml";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/internals/resource_url_impl.js
var ResourceUrlImpl = class {
  constructor(url, token) {
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedResourceUrl = url;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedResourceUrl.toString();
  }
};
var GlobalTrustedScriptURL = typeof window !== "undefined" ? window.TrustedScriptURL : void 0;
function createResourceUrlInternal(url) {
  var _a;
  const noinlineUrl = url;
  const trustedScriptURL = (_a = getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createScriptURL(noinlineUrl);
  return trustedScriptURL !== null && trustedScriptURL !== void 0 ? trustedScriptURL : new ResourceUrlImpl(noinlineUrl, secretToken);
}
function isResourceUrl(value) {
  var _a;
  return ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScriptURL(value)) || value instanceof ResourceUrlImpl;
}
function unwrapResourceUrl(value) {
  var _a;
  if ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScriptURL(value)) {
    return value;
  } else if (value instanceof ResourceUrlImpl) {
    return value.privateDoNotAccessOrElseWrappedResourceUrl;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping TrustedResourceUrl";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/internals/script_impl.js
var ScriptImpl = class {
  constructor(script, token) {
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedScript = script;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedScript.toString();
  }
};
function createTrustedScriptOrPolyfill(script, trusted) {
  return trusted !== null && trusted !== void 0 ? trusted : new ScriptImpl(script, secretToken);
}
var GlobalTrustedScript = typeof window !== "undefined" ? window.TrustedScript : void 0;
function createScriptInternal(script) {
  var _a;
  const noinlineScript = script;
  return createTrustedScriptOrPolyfill(noinlineScript, (_a = getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(noinlineScript));
}
var EMPTY_SCRIPT = (() => {
  var _a;
  return createTrustedScriptOrPolyfill("", (_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.emptyScript);
})();
function unwrapScript(value) {
  var _a;
  if ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScript(value)) {
    return value;
  } else if (value instanceof ScriptImpl) {
    return value.privateDoNotAccessOrElseWrappedScript;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping SafeScript";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/builders/html_builders.js
function nodeToHtmlInternal(node, temporaryRoot) {
  temporaryRoot.appendChild(node);
  let serializedNewTree = new XMLSerializer().serializeToString(temporaryRoot);
  serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf(">") + 1, serializedNewTree.lastIndexOf("</"));
  return createHtmlInternal(serializedNewTree);
}

// node_modules/safevalues/dist/mjs/internals/pure.js
function pure(valueOf) {
  return { valueOf }.valueOf();
}

// node_modules/safevalues/dist/mjs/builders/url_builders.js
function extractScheme(url) {
  let parsedUrl;
  try {
    parsedUrl = new URL(url);
  } catch (e) {
    return "https:";
  }
  return parsedUrl.protocol;
}
var ALLOWED_SCHEMES = ["data:", "http:", "https:", "mailto:", "ftp:"];
var IS_NOT_JAVASCRIPT_URL_PATTERN = /^\s*(?!javascript:)(?:[\w+.-]+:|[^:/?#]*(?:[/?#]|$))/i;
function reportJavaScriptUrl(url) {
  const hasJavascriptUrlScheme = !IS_NOT_JAVASCRIPT_URL_PATTERN.test(url);
  if (hasJavascriptUrlScheme) {
    if (true) {
      console.error(`A URL with content '${url}' was sanitized away.`);
    }
  }
  return hasJavascriptUrlScheme;
}
function sanitizeJavaScriptUrl(url) {
  if (reportJavaScriptUrl(url)) {
    return void 0;
  }
  return url;
}
function unwrapUrlOrSanitize(url) {
  return sanitizeJavaScriptUrl(url);
}
function restrictivelySanitizeUrl(url) {
  const parsedScheme = extractScheme(url);
  if (parsedScheme !== void 0 && ALLOWED_SCHEMES.indexOf(parsedScheme.toLowerCase()) !== -1) {
    return url;
  }
  return "about:invalid#zClosurez";
}

// node_modules/safevalues/dist/mjs/dom/globals/range.js
var range_exports = {};
__export(range_exports, {
  createContextualFragment: () => createContextualFragment
});
function createContextualFragment(range, html) {
  return range.createContextualFragment(unwrapHtml(html));
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/inert_fragment.js
function createInertFragment(dirtyHtml, inertDocument) {
  if (true) {
    if (inertDocument.defaultView) {
      throw new Error("createInertFragment called with non-inert document");
    }
  }
  const range = inertDocument.createRange();
  range.selectNode(inertDocument.body);
  const temporarySafeHtml = createHtmlInternal(dirtyHtml);
  return createContextualFragment(range, temporarySafeHtml);
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/no_clobber.js
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function isText(node) {
  return node.nodeType === 3;
}
function isElement(node) {
  const nodeType = node.nodeType;
  return nodeType === 1 || typeof nodeType !== "number";
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/resource_url_policy.js
var ResourceUrlPolicyHintsType;
(function(ResourceUrlPolicyHintsType2) {
  ResourceUrlPolicyHintsType2[ResourceUrlPolicyHintsType2["STYLE_TAG"] = 0] = "STYLE_TAG";
  ResourceUrlPolicyHintsType2[ResourceUrlPolicyHintsType2["STYLE_ATTRIBUTE"] = 1] = "STYLE_ATTRIBUTE";
  ResourceUrlPolicyHintsType2[ResourceUrlPolicyHintsType2["HTML_ATTRIBUTE"] = 2] = "HTML_ATTRIBUTE";
})(ResourceUrlPolicyHintsType || (ResourceUrlPolicyHintsType = {}));
function parseUrl(value) {
  try {
    return new URL(value, window.document.baseURI);
  } catch (e) {
    return new URL("about:invalid");
  }
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/sanitizer_table.js
var SanitizerTable = class {
  constructor(allowedElements, elementPolicies, allowedGlobalAttributes, globalAttributePolicies, globallyAllowedAttributePrefixes) {
    this.allowedElements = allowedElements;
    this.elementPolicies = elementPolicies;
    this.allowedGlobalAttributes = allowedGlobalAttributes;
    this.globalAttributePolicies = globalAttributePolicies;
    this.globallyAllowedAttributePrefixes = globallyAllowedAttributePrefixes;
  }
  isAllowedElement(elementName) {
    return elementName !== "FORM" && (this.allowedElements.has(elementName) || this.elementPolicies.has(elementName));
  }
  getAttributePolicy(attributeName, elementName) {
    const elementPolicy = this.elementPolicies.get(elementName);
    if (elementPolicy === null || elementPolicy === void 0 ? void 0 : elementPolicy.has(attributeName)) {
      return elementPolicy.get(attributeName);
    }
    if (this.allowedGlobalAttributes.has(attributeName)) {
      return { policyAction: AttributePolicyAction.KEEP };
    }
    const globalPolicy = this.globalAttributePolicies.get(attributeName);
    if (globalPolicy) {
      return globalPolicy;
    }
    if (this.globallyAllowedAttributePrefixes && [...this.globallyAllowedAttributePrefixes].some((prefix) => attributeName.indexOf(prefix) === 0)) {
      return { policyAction: AttributePolicyAction.KEEP };
    }
    return { policyAction: AttributePolicyAction.DROP };
  }
};
var AttributePolicyAction;
(function(AttributePolicyAction2) {
  AttributePolicyAction2[AttributePolicyAction2["DROP"] = 0] = "DROP";
  AttributePolicyAction2[AttributePolicyAction2["KEEP"] = 1] = "KEEP";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_SANITIZE_URL"] = 2] = "KEEP_AND_SANITIZE_URL";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_NORMALIZE"] = 3] = "KEEP_AND_NORMALIZE";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_SANITIZE_STYLE"] = 4] = "KEEP_AND_SANITIZE_STYLE";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_USE_RESOURCE_URL_POLICY"] = 5] = "KEEP_AND_USE_RESOURCE_URL_POLICY";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET"] = 6] = "KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET";
})(AttributePolicyAction || (AttributePolicyAction = {}));

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/default_sanitizer_table.js
var ALLOWED_ELEMENTS = [
  "ARTICLE",
  "SECTION",
  "NAV",
  "ASIDE",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "FOOTER",
  "ADDRESS",
  "P",
  "HR",
  "PRE",
  "BLOCKQUOTE",
  "OL",
  "UL",
  "LH",
  "LI",
  "DL",
  "DT",
  "DD",
  "FIGURE",
  "FIGCAPTION",
  "MAIN",
  "DIV",
  "EM",
  "STRONG",
  "SMALL",
  "S",
  "CITE",
  "Q",
  "DFN",
  "ABBR",
  "RUBY",
  "RB",
  "RT",
  "RTC",
  "RP",
  "DATA",
  "TIME",
  "CODE",
  "VAR",
  "SAMP",
  "KBD",
  "SUB",
  "SUP",
  "I",
  "B",
  "U",
  "MARK",
  "BDI",
  "BDO",
  "SPAN",
  "BR",
  "WBR",
  "INS",
  "DEL",
  "PICTURE",
  "PARAM",
  "TRACK",
  "MAP",
  "TABLE",
  "CAPTION",
  "COLGROUP",
  "COL",
  "TBODY",
  "THEAD",
  "TFOOT",
  "TR",
  "TD",
  "TH",
  "SELECT",
  "DATALIST",
  "OPTGROUP",
  "OPTION",
  "OUTPUT",
  "PROGRESS",
  "METER",
  "FIELDSET",
  "LEGEND",
  "DETAILS",
  "SUMMARY",
  "MENU",
  "DIALOG",
  "SLOT",
  "CANVAS",
  "FONT",
  "CENTER",
  "ACRONYM",
  "BASEFONT",
  "BIG",
  "DIR",
  "HGROUP",
  "STRIKE",
  "TT"
];
var ELEMENT_POLICIES = [
  [
    "A",
    /* @__PURE__ */ new Map([
      [
        "href",
        {
          policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
        }
      ]
    ])
  ],
  [
    "AREA",
    /* @__PURE__ */ new Map([
      [
        "href",
        {
          policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
        }
      ]
    ])
  ],
  [
    "LINK",
    /* @__PURE__ */ new Map([
      [
        "href",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY,
          conditions: /* @__PURE__ */ new Map([
            [
              "rel",
              /* @__PURE__ */ new Set([
                "alternate",
                "author",
                "bookmark",
                "canonical",
                "cite",
                "help",
                "icon",
                "license",
                "next",
                "prefetch",
                "dns-prefetch",
                "prerender",
                "preconnect",
                "preload",
                "prev",
                "search",
                "subresource"
              ])
            ]
          ])
        }
      ]
    ])
  ],
  [
    "SOURCE",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ],
      [
        "srcset",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET
        }
      ]
    ])
  ],
  [
    "IMG",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ],
      [
        "srcset",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET
        }
      ]
    ])
  ],
  [
    "VIDEO",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ]
    ])
  ],
  [
    "AUDIO",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ]
    ])
  ]
];
var ALLOWED_GLOBAL_ATTRIBUTES = [
  "title",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-current",
  "aria-disabled",
  "aria-dropeffect",
  "aria-expanded",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-label",
  "aria-level",
  "aria-live",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "alt",
  "align",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "autoplay",
  "bgcolor",
  "border",
  "cellpadding",
  "cellspacing",
  "checked",
  "color",
  "cols",
  "colspan",
  "controls",
  "datetime",
  "disabled",
  "download",
  "draggable",
  "enctype",
  "face",
  "formenctype",
  "frameborder",
  "height",
  "hreflang",
  "hidden",
  "ismap",
  "label",
  "lang",
  "loop",
  "max",
  "maxlength",
  "media",
  "minlength",
  "min",
  "multiple",
  "muted",
  "nonce",
  "open",
  "placeholder",
  "preload",
  "rel",
  "required",
  "reversed",
  "role",
  "rows",
  "rowspan",
  "selected",
  "shape",
  "size",
  "sizes",
  "slot",
  "span",
  "spellcheck",
  "start",
  "step",
  "summary",
  "translate",
  "type",
  "valign",
  "value",
  "width",
  "wrap",
  "itemscope",
  "itemtype",
  "itemid",
  "itemprop",
  "itemref"
];
var GLOBAL_ATTRIBUTE_POLICIES = [
  [
    "dir",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["dir", /* @__PURE__ */ new Set(["auto", "ltr", "rtl"])]
        ]);
      })
    }
  ],
  [
    "async",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["async", /* @__PURE__ */ new Set(["async"])]
        ]);
      })
    }
  ],
  [
    "cite",
    {
      policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
    }
  ],
  [
    "loading",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["loading", /* @__PURE__ */ new Set(["eager", "lazy"])]
        ]);
      })
    }
  ],
  [
    "poster",
    {
      policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
    }
  ],
  [
    "target",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["target", /* @__PURE__ */ new Set(["_self", "_blank"])]
        ]);
      })
    }
  ]
];
var DEFAULT_SANITIZER_TABLE = new SanitizerTable(new Set(ALLOWED_ELEMENTS), new Map(ELEMENT_POLICIES), new Set(ALLOWED_GLOBAL_ATTRIBUTES), new Map(GLOBAL_ATTRIBUTE_POLICIES));
var CSS_SANITIZER_TABLE = new SanitizerTable(
  new Set(pure(() => ALLOWED_ELEMENTS.concat(["STYLE"]))),
  new Map(ELEMENT_POLICIES),
  // We allow id, name, and class because they can be used in CSS selectors.
  // Shadow DOM ensures that those names don't clash with other names in the
  // document.
  new Set(
    pure(() => ALLOWED_GLOBAL_ATTRIBUTES.concat(["id", "name", "class"]))
  ),
  new Map(
    pure(() => GLOBAL_ATTRIBUTE_POLICIES.concat([
      [
        "style",
        { policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_STYLE }
      ]
    ]))
  )
);

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/html_sanitizer.js
var HtmlSanitizerImpl = class {
  constructor(sanitizerTable, token, styleElementSanitizer, styleAttributeSanitizer, resourceUrlPolicy) {
    this.sanitizerTable = sanitizerTable;
    this.styleElementSanitizer = styleElementSanitizer;
    this.styleAttributeSanitizer = styleAttributeSanitizer;
    this.resourceUrlPolicy = resourceUrlPolicy;
    this.changes = [];
    ensureTokenIsValid(token);
  }
  sanitizeAssertUnchanged(html) {
    if (true) {
      this.changes = [];
    }
    const sanitizedHtml = this.sanitize(html);
    if (this.changes.length !== 0) {
      throw new Error(`Unexpected change to HTML value as a result of sanitization. Input: "${html}", sanitized output: "${sanitizedHtml}"
List of changes:${this.changes.join("\n")}`);
    }
    return sanitizedHtml;
  }
  sanitize(html) {
    const inertDocument = document.implementation.createHTMLDocument("");
    return nodeToHtmlInternal(this.sanitizeToFragmentInternal(html, inertDocument), inertDocument.body);
  }
  sanitizeToFragment(html) {
    const inertDocument = document.implementation.createHTMLDocument("");
    return this.sanitizeToFragmentInternal(html, inertDocument);
  }
  sanitizeToFragmentInternal(html, inertDocument) {
    const dirtyFragment = createInertFragment(html, inertDocument);
    const treeWalker = document.createTreeWalker(dirtyFragment, 5, (n) => this.nodeFilter(n));
    let currentNode = treeWalker.nextNode();
    const sanitizedFragment = inertDocument.createDocumentFragment();
    let sanitizedParent = sanitizedFragment;
    while (currentNode !== null) {
      let sanitizedNode;
      if (isText(currentNode)) {
        if (this.styleElementSanitizer && sanitizedParent.nodeName === "STYLE") {
          const sanitizedCss = this.styleElementSanitizer(currentNode.data);
          sanitizedNode = this.createTextNode(sanitizedCss);
        } else {
          sanitizedNode = this.sanitizeTextNode(currentNode);
        }
      } else if (isElement(currentNode)) {
        sanitizedNode = this.sanitizeElementNode(currentNode, inertDocument);
      } else {
        let message = "";
        if (true) {
          message = "Node is not of type text or element";
        }
        throw new Error(message);
      }
      sanitizedParent.appendChild(sanitizedNode);
      currentNode = treeWalker.firstChild();
      if (currentNode) {
        sanitizedParent = sanitizedNode;
      } else {
        while (!(currentNode = treeWalker.nextSibling())) {
          if (!(currentNode = treeWalker.parentNode())) {
            break;
          }
          sanitizedParent = sanitizedParent.parentNode;
        }
      }
    }
    return sanitizedFragment;
  }
  createTextNode(text) {
    return document.createTextNode(text);
  }
  sanitizeTextNode(textNode) {
    return this.createTextNode(textNode.data);
  }
  sanitizeElementNode(elementNode, inertDocument) {
    const elementName = getNodeName(elementNode);
    const newNode = inertDocument.createElement(elementName);
    const dirtyAttributes = elementNode.attributes;
    for (const { name: name2, value } of dirtyAttributes) {
      const policy = this.sanitizerTable.getAttributePolicy(name2, elementName);
      if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {
        this.recordChange(`Not all conditions satisfied for attribute: ${name2}.`);
        continue;
      }
      switch (policy.policyAction) {
        case AttributePolicyAction.KEEP:
          setAttribute(newNode, name2, value);
          break;
        case AttributePolicyAction.KEEP_AND_SANITIZE_URL:
          const sanitizedAttrUrl = restrictivelySanitizeUrl(value);
          if (sanitizedAttrUrl !== value) {
            this.recordChange(`Url in attribute ${name2} was modified during sanitization. Original url:"${value}" was sanitized to: "${sanitizedAttrUrl}"`);
          }
          setAttribute(newNode, name2, sanitizedAttrUrl);
          break;
        case AttributePolicyAction.KEEP_AND_NORMALIZE:
          setAttribute(newNode, name2, value.toLowerCase());
          break;
        case AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:
          if (this.styleAttributeSanitizer) {
            const sanitizedCss = this.styleAttributeSanitizer(value);
            setAttribute(newNode, name2, sanitizedCss);
          } else {
            setAttribute(newNode, name2, value);
          }
          break;
        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY:
          if (this.resourceUrlPolicy) {
            const hints = {
              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,
              attributeName: name2,
              tagName: elementName
            };
            const url = parseUrl(value);
            const sanitizedUrl = this.resourceUrlPolicy(url, hints);
            if (sanitizedUrl) {
              setAttribute(newNode, name2, sanitizedUrl.toString());
            }
          } else {
            setAttribute(newNode, name2, value);
          }
          break;
        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET:
          if (this.resourceUrlPolicy) {
            const hints = {
              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,
              attributeName: name2,
              tagName: elementName
            };
            const srcset = parseSrcset(value);
            const sanitizedSrcset = { parts: [] };
            for (const part of srcset.parts) {
              const url = parseUrl(part.url);
              const sanitizedUrl = this.resourceUrlPolicy(url, hints);
              if (sanitizedUrl) {
                sanitizedSrcset.parts.push({
                  url: sanitizedUrl.toString(),
                  descriptor: part.descriptor
                });
              }
            }
            setAttribute(newNode, name2, serializeSrcset(sanitizedSrcset));
          } else {
            setAttribute(newNode, name2, value);
          }
          break;
        case AttributePolicyAction.DROP:
          this.recordChange(`Attribute: ${name2} was dropped`);
          break;
        default:
          if (true) {
            checkExhaustive(policy.policyAction, "Unhandled AttributePolicyAction case");
          }
      }
    }
    return newNode;
  }
  nodeFilter(node) {
    if (isText(node)) {
      return 1;
    } else if (!isElement(node)) {
      return 2;
    }
    const nodeName = getNodeName(node);
    if (nodeName === null) {
      this.recordChange(`Node name was null for node: ${node}`);
      return 2;
    }
    if (this.sanitizerTable.isAllowedElement(nodeName)) {
      return 1;
    }
    this.recordChange(`Element: ${nodeName} was dropped`);
    return 2;
  }
  recordChange(errorMessage) {
    if (true) {
      this.changes.push(errorMessage);
    }
  }
  satisfiesAllConditions(conditions, attrs) {
    var _a;
    if (!conditions) {
      return true;
    }
    for (const [attrName, expectedValues] of conditions) {
      const value = (_a = attrs.getNamedItem(attrName)) === null || _a === void 0 ? void 0 : _a.value;
      if (value && !expectedValues.has(value)) {
        return false;
      }
    }
    return true;
  }
};
function setAttribute(el, name2, value) {
  el.setAttribute(name2, value);
}
function parseSrcset(srcset) {
  const parts = [];
  for (const part of srcset.split(",")) {
    const [url, descriptor] = part.trim().split(/\s+/, 2);
    parts.push({ url, descriptor });
  }
  return { parts };
}
function serializeSrcset(srcset) {
  return srcset.parts.map((part) => {
    const { url, descriptor } = part;
    return `${url}${descriptor ? ` ${descriptor}` : ""}`;
  }).join(" , ");
}
var defaultHtmlSanitizer = pure(() => new HtmlSanitizerImpl(DEFAULT_SANITIZER_TABLE, secretToken));
function checkExhaustive(value, msg = `unexpected value ${value}!`) {
  throw new Error(msg);
}

// node_modules/safevalues/dist/mjs/builders/resource_url_builders.js
function hasValidOrigin(base) {
  if (!(/^https:\/\//.test(base) || /^\/\//.test(base))) {
    return false;
  }
  const originStart = base.indexOf("//") + 2;
  const originEnd = base.indexOf("/", originStart);
  if (originEnd <= originStart) {
    throw new Error(`Can't interpolate data in a url's origin, Please make sure to fully specify the origin, terminated with '/'.`);
  }
  const origin = base.substring(originStart, originEnd);
  if (!/^[0-9a-z.:-]+$/i.test(origin)) {
    throw new Error("The origin contains unsupported characters.");
  }
  if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {
    throw new Error("Invalid port number.");
  }
  if (!/(^|\.)[a-z][^.]*$/i.test(origin)) {
    throw new Error("The top-level domain must start with a letter.");
  }
  return true;
}
function isValidAboutUrl(base) {
  if (!/^about:blank/.test(base)) {
    return false;
  }
  if (base !== "about:blank" && !/^about:blank#/.test(base)) {
    throw new Error("The about url is invalid.");
  }
  return true;
}
function isValidPathStart(base) {
  if (!/^\//.test(base)) {
    return false;
  }
  if (base === "/" || base.length > 1 && base[1] !== "/" && base[1] !== "\\") {
    return true;
  }
  throw new Error("The path start in the url is invalid.");
}
function isValidRelativePathStart(base) {
  return new RegExp("^[^:\\s\\\\/]+/").test(base);
}
function trustedResourceUrl(templateObj, ...rest) {
  if (true) {
    assertIsTemplateObject(templateObj, rest.length);
  }
  if (rest.length === 0) {
    return createResourceUrlInternal(templateObj[0]);
  }
  const base = templateObj[0].toLowerCase();
  if (true) {
    if (/^data:/.test(base)) {
      throw new Error("Data URLs cannot have expressions in the template literal input.");
    }
    if (!hasValidOrigin(base) && !isValidPathStart(base) && !isValidRelativePathStart(base) && !isValidAboutUrl(base)) {
      throw new Error("Trying to interpolate expressions in an unsupported url format.");
    }
  }
  let url = templateObj[0];
  for (let i = 0; i < rest.length; i++) {
    url += encodeURIComponent(rest[i]) + templateObj[i + 1];
  }
  return createResourceUrlInternal(url);
}

// node_modules/safevalues/dist/mjs/internals/style_sheet_impl.js
var SafeStyleSheet = class {
};
var StyleSheetImpl = class extends SafeStyleSheet {
  constructor(styleSheet, token) {
    super();
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedStyleSheet = styleSheet;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedStyleSheet;
  }
};
function createStyleSheetInternal(styleSheet) {
  return new StyleSheetImpl(styleSheet, secretToken);
}
function unwrapStyleSheet(value) {
  if (value instanceof StyleSheetImpl) {
    return value.privateDoNotAccessOrElseWrappedStyleSheet;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping SafeStyleSheet";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/anchor.js
var anchor_exports = {};
__export(anchor_exports, {
  setHref: () => setHref
});
function setHref(anchor, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    anchor.href = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/area.js
var area_exports = {};
__export(area_exports, {
  setHref: () => setHref2
});
function setHref2(area, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    area.href = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/base.js
var base_exports = {};
__export(base_exports, {
  setHref: () => setHref3
});
function setHref3(baseEl, url) {
  baseEl.href = unwrapResourceUrl(url);
}

// node_modules/safevalues/dist/mjs/dom/elements/button.js
var button_exports = {};
__export(button_exports, {
  setFormaction: () => setFormaction
});
function setFormaction(button, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    button.formAction = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/element.js
var element_exports = {};
__export(element_exports, {
  buildPrefixedAttributeSetter: () => buildPrefixedAttributeSetter,
  insertAdjacentHtml: () => insertAdjacentHtml,
  setInnerHtml: () => setInnerHtml,
  setOuterHtml: () => setOuterHtml,
  setPrefixedAttribute: () => setPrefixedAttribute
});
function setInnerHtml(elOrRoot, v) {
  if (isElement2(elOrRoot)) {
    throwIfScriptOrStyle(elOrRoot);
  }
  elOrRoot.innerHTML = unwrapHtml(v);
}
function setOuterHtml(e, v) {
  const parent = e.parentElement;
  if (parent !== null) {
    throwIfScriptOrStyle(parent);
  }
  e.outerHTML = unwrapHtml(v);
}
function insertAdjacentHtml(element, position, v) {
  const tagContext = position === "beforebegin" || position === "afterend" ? element.parentElement : element;
  if (tagContext !== null) {
    throwIfScriptOrStyle(tagContext);
  }
  element.insertAdjacentHTML(position, unwrapHtml(v));
}
function buildPrefixedAttributeSetter(prefix, ...otherPrefixes) {
  const prefixes = [prefix, ...otherPrefixes];
  return (e, attr, value) => {
    setPrefixedAttribute(prefixes, e, attr, value);
  };
}
function setPrefixedAttribute(attrPrefixes, e, attr, value) {
  if (attrPrefixes.length === 0) {
    let message = "";
    if (true) {
      message = "No prefixes are provided";
    }
    throw new Error(message);
  }
  const prefixes = attrPrefixes.map((s) => unwrapAttributePrefix(s));
  const attrLower = attr.toLowerCase();
  if (prefixes.every((p) => attrLower.indexOf(p) !== 0)) {
    throw new Error(`Attribute "${attr}" does not match any of the allowed prefixes.`);
  }
  e.setAttribute(attr, value);
}
function throwIfScriptOrStyle(element) {
  let message = "";
  const tagName = element.tagName;
  if (tagName === "SCRIPT" || tagName === "STYLE") {
    if (true) {
      if (tagName === "SCRIPT") {
        message = "Use safeScriptEl.setTextContent with a SafeScript.";
      } else {
        message = "Use safeStyleEl.setTextContent with a SafeStyleSheet.";
      }
    }
    throw new Error(message);
  }
}
function isElement2(elOrRoot) {
  return elOrRoot.nodeType === 1;
}

// node_modules/safevalues/dist/mjs/dom/elements/embed.js
var embed_exports = {};
__export(embed_exports, {
  setSrc: () => setSrc
});
function setSrc(embedEl, url) {
  embedEl.src = unwrapResourceUrl(url);
}

// node_modules/safevalues/dist/mjs/dom/elements/form.js
var form_exports = {};
__export(form_exports, {
  setAction: () => setAction
});
function setAction(form, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    form.action = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/iframe.js
var iframe_exports = {};
__export(iframe_exports, {
  setSrc: () => setSrc2,
  setSrcdoc: () => setSrcdoc
});
function setSrc2(iframe, v) {
  iframe.src = unwrapResourceUrl(v).toString();
}
function setSrcdoc(iframe, v) {
  iframe.srcdoc = unwrapHtml(v);
}

// node_modules/safevalues/dist/mjs/dom/elements/input.js
var input_exports = {};
__export(input_exports, {
  setFormaction: () => setFormaction2
});
function setFormaction2(input, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    input.formAction = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/link.js
var link_exports = {};
__export(link_exports, {
  setHrefAndRel: () => setHrefAndRel,
  setHrefAndRelWithTrustedResourceUrl: () => setHrefAndRelWithTrustedResourceUrl
});
var SAFE_URL_REL_VALUES = [
  "alternate",
  "author",
  "bookmark",
  "canonical",
  "cite",
  "help",
  "icon",
  "license",
  "modulepreload",
  "next",
  "prefetch",
  "dns-prefetch",
  "prerender",
  "preconnect",
  "preload",
  "prev",
  "search",
  "subresource"
];
function setHrefAndRel(link, url, rel) {
  if (isResourceUrl(url)) {
    setHrefAndRelWithTrustedResourceUrl(link, url, rel);
    return;
  } else {
    if (SAFE_URL_REL_VALUES.indexOf(rel) === -1) {
      throw new Error(`TrustedResourceUrl href attribute required with rel="${rel}"`);
    }
    const sanitizedUrl = unwrapUrlOrSanitize(url);
    if (sanitizedUrl === void 0) {
      return;
    }
    link.href = sanitizedUrl;
  }
  link.rel = rel;
}
function setHrefAndRelWithTrustedResourceUrl(link, url, rel) {
  link.href = unwrapResourceUrl(url).toString();
  link.rel = rel;
}

// node_modules/safevalues/dist/mjs/dom/elements/object.js
var object_exports = {};
__export(object_exports, {
  setData: () => setData
});
function setData(obj, v) {
  obj.data = unwrapResourceUrl(v);
}

// node_modules/safevalues/dist/mjs/dom/elements/script.js
var script_exports = {};
__export(script_exports, {
  setSrc: () => setSrc3,
  setTextContent: () => setTextContent
});

// node_modules/safevalues/dist/mjs/dom/globals/window.js
var window_exports = {};
__export(window_exports, {
  getScriptNonce: () => getScriptNonce,
  getStyleNonce: () => getStyleNonce,
  open: () => open
});
function open(win, url, target, features) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    return win.open(sanitizedUrl, target, features);
  }
  return null;
}
function getScriptNonce(win) {
  return getNonceFor("script", win);
}
function getStyleNonce(win) {
  return getNonceFor("style", win);
}
function getNonceFor(elementName, win) {
  var _a;
  const doc = win.document;
  const el = (_a = doc.querySelector) === null || _a === void 0 ? void 0 : _a.call(doc, `${elementName}[nonce]`);
  if (el) {
    return el["nonce"] || el.getAttribute("nonce") || "";
  }
  return "";
}

// node_modules/safevalues/dist/mjs/dom/elements/script.js
function setNonceForScriptElement(script) {
  const win = script.ownerDocument && script.ownerDocument.defaultView;
  const nonce = getScriptNonce(win || window);
  if (nonce) {
    script.setAttribute("nonce", nonce);
  }
}
function setTextContent(script, v, options) {
  script.textContent = unwrapScript(v);
  if (options === null || options === void 0 ? void 0 : options.omitNonce)
    return;
  setNonceForScriptElement(script);
}
function setSrc3(script, v, options) {
  script.src = unwrapResourceUrl(v);
  if (options === null || options === void 0 ? void 0 : options.omitNonce)
    return;
  setNonceForScriptElement(script);
}

// node_modules/safevalues/dist/mjs/dom/elements/style.js
var style_exports = {};
__export(style_exports, {
  setTextContent: () => setTextContent2
});
function setTextContent2(elem, safeStyleSheet2) {
  elem.textContent = unwrapStyleSheet(safeStyleSheet2);
}

// node_modules/safevalues/dist/mjs/dom/elements/svg.js
var svg_exports = {};
__export(svg_exports, {
  setAttribute: () => setAttribute2
});
var UNSAFE_SVG_ATTRIBUTES = ["href", "xlink:href"];
function setAttribute2(svg, attr, value) {
  const attrLower = attr.toLowerCase();
  if (UNSAFE_SVG_ATTRIBUTES.indexOf(attrLower) !== -1 || attrLower.indexOf("on") === 0) {
    let msg = "";
    if (true) {
      msg = `Setting the '${attrLower}' attribute on SVG can cause XSS.`;
    }
    throw new Error(msg);
  }
  svg.setAttribute(attr, value);
}

// node_modules/safevalues/dist/mjs/dom/elements/svg_use.js
var svg_use_exports = {};
__export(svg_use_exports, {
  setHref: () => setHref4
});
function setHref4(useEl, url) {
  const scheme = extractScheme(url);
  if (scheme === "javascript:" || scheme === "data:") {
    if (true) {
      const msg = `A URL with content '${url}' was sanitized away.`;
      console.error(msg);
    }
    return;
  }
  useEl.setAttribute("href", url);
}

// node_modules/safevalues/dist/mjs/dom/globals/document.js
var document_exports = {};
__export(document_exports, {
  execCommand: () => execCommand,
  execCommandInsertHtml: () => execCommandInsertHtml,
  write: () => write
});
function write(doc, text) {
  doc.write(unwrapHtml(text));
}
function execCommand(doc, command, value) {
  const commandString = String(command);
  let valueArgument = value;
  if (commandString.toLowerCase() === "inserthtml") {
    valueArgument = unwrapHtml(value);
  }
  return doc.execCommand(
    commandString,
    /* showUi= */
    false,
    valueArgument
  );
}
function execCommandInsertHtml(doc, html) {
  return doc.execCommand(
    "insertHTML",
    /* showUi= */
    false,
    unwrapHtml(html)
  );
}

// node_modules/safevalues/dist/mjs/dom/globals/dom_parser.js
var dom_parser_exports = {};
__export(dom_parser_exports, {
  parseFromString: () => parseFromString,
  parseHtml: () => parseHtml,
  parseXml: () => parseXml
});
function parseHtml(parser, html) {
  return parseFromString(parser, html, "text/html");
}
function parseXml(parser, xml) {
  const doc = parseFromString(parser, createHtmlInternal(xml), "text/xml");
  const iterator = document.createNodeIterator(doc, NodeFilter.SHOW_ALL);
  let currentNode;
  while (currentNode = iterator.nextNode()) {
    if (currentNode instanceof HTMLElement || currentNode instanceof SVGElement) {
      let message = "unsafe XML";
      if (true) {
        message = `attempted to parse an XML document that embeds HTML or SVG content`;
      }
      throw new Error(message);
    }
  }
  return doc;
}
function parseFromString(parser, content, contentType) {
  return parser.parseFromString(unwrapHtml(content), contentType);
}

// node_modules/safevalues/dist/mjs/dom/globals/global.js
var global_exports = {};
__export(global_exports, {
  fetchResourceUrl: () => fetchResourceUrl,
  globalEval: () => globalEval
});

// node_modules/safevalues/dist/mjs/dom/globals/fetch.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IncorrectContentTypeError = class extends Error {
  constructor(url, typeName, contentType) {
    super(`${url} was requested as a ${typeName}, but the response Content-Type, "${contentType} is not appropriate for this type of content.`);
    this.url = url;
    this.typeName = typeName;
    this.contentType = contentType;
  }
};
function privatecreateHtmlInternal(html) {
  return createHtmlInternal(html);
}
function fetchResourceUrl(u, init) {
  var _a, _b, _c;
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield fetch(unwrapResourceUrl(u).toString(), init);
    const mimeType = (_c = (_b = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.split(";", 2)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.toLowerCase();
    return {
      html() {
        return __awaiter(this, void 0, void 0, function* () {
          if (mimeType !== "text/html") {
            throw new IncorrectContentTypeError(response.url, "SafeHtml", "text/html");
          }
          const text = yield response.text();
          return privatecreateHtmlInternal(text);
        });
      },
      script() {
        return __awaiter(this, void 0, void 0, function* () {
          if (mimeType !== "text/javascript" && mimeType !== "application/javascript") {
            throw new IncorrectContentTypeError(response.url, "SafeScript", "text/javascript");
          }
          const text = yield response.text();
          return createScriptInternal(text);
        });
      },
      styleSheet() {
        return __awaiter(this, void 0, void 0, function* () {
          if (mimeType !== "text/css") {
            throw new IncorrectContentTypeError(response.url, "SafeStyleSheet", "text/css");
          }
          const text = yield response.text();
          return createStyleSheetInternal(text);
        });
      }
    };
  });
}

// node_modules/safevalues/dist/mjs/dom/globals/global.js
function globalEval(win, script) {
  const trustedScript = unwrapScript(script);
  let result = win.eval(trustedScript);
  if (result === trustedScript) {
    result = win.eval(trustedScript.toString());
  }
  return result;
}

// node_modules/safevalues/dist/mjs/dom/globals/location.js
var location_exports = {};
__export(location_exports, {
  assign: () => assign,
  replace: () => replace,
  setHref: () => setHref5
});
function setHref5(loc, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    loc.href = sanitizedUrl;
  }
}
function replace(loc, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    loc.replace(sanitizedUrl);
  }
}
function assign(loc, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    loc.assign(sanitizedUrl);
  }
}

// node_modules/safevalues/dist/mjs/dom/globals/service_worker_container.js
var service_worker_container_exports = {};
__export(service_worker_container_exports, {
  register: () => register
});
function register(container, scriptURL, options) {
  return container.register(unwrapResourceUrl(scriptURL), options);
}

// node_modules/safevalues/dist/mjs/dom/globals/url.js
var url_exports = {};
__export(url_exports, {
  objectUrlFromSafeSource: () => objectUrlFromSafeSource
});
function isSafeMimeType(mimeType) {
  const match = mimeType.match(/^([^;]+)(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i);
  return (match === null || match === void 0 ? void 0 : match.length) === 2 && (isSafeImageMimeType(match[1]) || isSafeVideoMimeType(match[1]) || isSafeAudioMimeType(match[1]));
}
function isSafeImageMimeType(mimeType) {
  return /^image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon|heic|heif)$/i.test(mimeType);
}
function isSafeVideoMimeType(mimeType) {
  return /^video\/(?:mpeg|mp4|ogg|webm|x-matroska|quicktime|x-ms-wmv)$/i.test(mimeType);
}
function isSafeAudioMimeType(mimeType) {
  return /^audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)$/i.test(mimeType);
}
function objectUrlFromSafeSource(source) {
  if (typeof MediaSource !== "undefined" && source instanceof MediaSource) {
    return URL.createObjectURL(source);
  }
  const blob = source;
  if (!isSafeMimeType(blob.type)) {
    let message = "";
    if (true) {
      message = `unsafe blob MIME type: ${blob.type}`;
    }
    throw new Error(message);
  }
  return URL.createObjectURL(blob);
}

// node_modules/safevalues/dist/mjs/dom/globals/worker.js
var worker_exports = {};
__export(worker_exports, {
  create: () => create,
  createShared: () => createShared,
  importScripts: () => importScripts
});
function create(url, options) {
  return new Worker(unwrapResourceUrl(url), options);
}
function createShared(url, options) {
  return new SharedWorker(unwrapResourceUrl(url), options);
}
function importScripts(scope, ...urls) {
  scope.importScripts(...urls.map((url) => unwrapResourceUrl(url)));
}

// node_modules/@firebase/analytics/dist/esm/index.esm2017.js
var ANALYTICS_TYPE = "analytics";
var GA_FID_KEY = "firebase_id";
var ORIGIN_KEY = "origin";
var FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DYNAMIC_CONFIG_URL = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig";
var GTAG_URL = "https://www.googletagmanager.com/gtag/js";
var logger = new Logger("@firebase/analytics");
function promiseAllSettled(promises) {
  return Promise.all(promises.map((promise) => promise.catch((e) => e)));
}
function insertScriptTag(dataLayerName2, measurementId) {
  const script = document.createElement("script");
  const url = trustedResourceUrl`https://www.googletagmanager.com/gtag/js?l=${dataLayerName2}&id=${measurementId}`;
  script_exports.setSrc(script, url);
  script.async = true;
  document.head.appendChild(script);
}
function getOrCreateDataLayer(dataLayerName2) {
  let dataLayer = [];
  if (Array.isArray(window[dataLayerName2])) {
    dataLayer = window[dataLayerName2];
  } else {
    window[dataLayerName2] = dataLayer;
  }
  return dataLayer;
}
async function gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams) {
  const correspondingAppId = measurementIdToAppId2[measurementId];
  try {
    if (correspondingAppId) {
      await initializationPromisesMap2[correspondingAppId];
    } else {
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      const foundConfig = dynamicConfigResults.find((config) => config.measurementId === measurementId);
      if (foundConfig) {
        await initializationPromisesMap2[foundConfig.appId];
      }
    }
  } catch (e) {
    logger.error(e);
  }
  gtagCore("config", measurementId, gtagParams);
}
async function gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams) {
  try {
    let initializationPromisesToWaitFor = [];
    if (gtagParams && gtagParams["send_to"]) {
      let gaSendToList = gtagParams["send_to"];
      if (!Array.isArray(gaSendToList)) {
        gaSendToList = [gaSendToList];
      }
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      for (const sendToId of gaSendToList) {
        const foundConfig = dynamicConfigResults.find((config) => config.measurementId === sendToId);
        const initializationPromise = foundConfig && initializationPromisesMap2[foundConfig.appId];
        if (initializationPromise) {
          initializationPromisesToWaitFor.push(initializationPromise);
        } else {
          initializationPromisesToWaitFor = [];
          break;
        }
      }
    }
    if (initializationPromisesToWaitFor.length === 0) {
      initializationPromisesToWaitFor = Object.values(initializationPromisesMap2);
    }
    await Promise.all(initializationPromisesToWaitFor);
    gtagCore("event", measurementId, gtagParams || {});
  } catch (e) {
    logger.error(e);
  }
}
function wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2) {
  async function gtagWrapper(command, ...args) {
    try {
      if (command === "event") {
        const [measurementId, gtagParams] = args;
        await gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams);
      } else if (command === "config") {
        const [measurementId, gtagParams] = args;
        await gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams);
      } else if (command === "consent") {
        const [consentAction, gtagParams] = args;
        gtagCore("consent", consentAction, gtagParams);
      } else if (command === "get") {
        const [measurementId, fieldName, callback] = args;
        gtagCore("get", measurementId, fieldName, callback);
      } else if (command === "set") {
        const [customParams] = args;
        gtagCore("set", customParams);
      } else {
        gtagCore(command, ...args);
      }
    } catch (e) {
      logger.error(e);
    }
  }
  return gtagWrapper;
}
function wrapOrCreateGtag(initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, dataLayerName2, gtagFunctionName) {
  let gtagCore = function(..._args) {
    window[dataLayerName2].push(arguments);
  };
  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === "function") {
    gtagCore = window[gtagFunctionName];
  }
  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2);
  return {
    gtagCore,
    wrappedGtag: window[gtagFunctionName]
  };
}
function findGtagScriptOnPage(dataLayerName2) {
  const scriptTags = window.document.getElementsByTagName("script");
  for (const tag of Object.values(scriptTags)) {
    if (tag.src && tag.src.includes(GTAG_URL) && tag.src.includes(dataLayerName2)) {
      return tag;
    }
  }
  return null;
}
var ERRORS = {
  [
    "already-exists"
    /* AnalyticsError.ALREADY_EXISTS */
  ]: "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
  [
    "already-initialized"
    /* AnalyticsError.ALREADY_INITIALIZED */
  ]: "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.",
  [
    "already-initialized-settings"
    /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */
  ]: "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
  [
    "interop-component-reg-failed"
    /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */
  ]: "Firebase Analytics Interop Component failed to instantiate: {$reason}",
  [
    "invalid-analytics-context"
    /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */
  ]: "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  [
    "indexeddb-unavailable"
    /* AnalyticsError.INDEXEDDB_UNAVAILABLE */
  ]: "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  [
    "fetch-throttle"
    /* AnalyticsError.FETCH_THROTTLE */
  ]: "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
  [
    "config-fetch-failed"
    /* AnalyticsError.CONFIG_FETCH_FAILED */
  ]: "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
  [
    "no-api-key"
    /* AnalyticsError.NO_API_KEY */
  ]: 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
  [
    "no-app-id"
    /* AnalyticsError.NO_APP_ID */
  ]: 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
  [
    "no-client-id"
    /* AnalyticsError.NO_CLIENT_ID */
  ]: 'The "client_id" field is empty.',
  [
    "invalid-gtag-resource"
    /* AnalyticsError.INVALID_GTAG_RESOURCE */
  ]: "Trusted Types detected an invalid gtag resource: {$gtagURL}."
};
var ERROR_FACTORY = new ErrorFactory("analytics", "Analytics", ERRORS);
var LONG_RETRY_FACTOR = 30;
var BASE_INTERVAL_MILLIS = 1e3;
var RetryData = class {
  constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {
    this.throttleMetadata = throttleMetadata;
    this.intervalMillis = intervalMillis;
  }
  getThrottleMetadata(appId) {
    return this.throttleMetadata[appId];
  }
  setThrottleMetadata(appId, metadata) {
    this.throttleMetadata[appId] = metadata;
  }
  deleteThrottleMetadata(appId) {
    delete this.throttleMetadata[appId];
  }
};
var defaultRetryData = new RetryData();
function getHeaders(apiKey) {
  return new Headers({
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
async function fetchDynamicConfig(appFields) {
  var _a;
  const { appId, apiKey } = appFields;
  const request = {
    method: "GET",
    headers: getHeaders(apiKey)
  };
  const appUrl = DYNAMIC_CONFIG_URL.replace("{app-id}", appId);
  const response = await fetch(appUrl, request);
  if (response.status !== 200 && response.status !== 304) {
    let errorMessage = "";
    try {
      const jsonResponse = await response.json();
      if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {
        errorMessage = jsonResponse.error.message;
      }
    } catch (_ignored) {
    }
    throw ERROR_FACTORY.create("config-fetch-failed", {
      httpStatus: response.status,
      responseMessage: errorMessage
    });
  }
  return response.json();
}
async function fetchDynamicConfigWithRetry(app, retryData = defaultRetryData, timeoutMillis) {
  const { appId, apiKey, measurementId } = app.options;
  if (!appId) {
    throw ERROR_FACTORY.create(
      "no-app-id"
      /* AnalyticsError.NO_APP_ID */
    );
  }
  if (!apiKey) {
    if (measurementId) {
      return {
        measurementId,
        appId
      };
    }
    throw ERROR_FACTORY.create(
      "no-api-key"
      /* AnalyticsError.NO_API_KEY */
    );
  }
  const throttleMetadata = retryData.getThrottleMetadata(appId) || {
    backoffCount: 0,
    throttleEndTimeMillis: Date.now()
  };
  const signal = new AnalyticsAbortSignal();
  setTimeout(async () => {
    signal.abort();
  }, timeoutMillis !== void 0 ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
  return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);
}
async function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData) {
  var _a;
  const { appId, measurementId } = appFields;
  try {
    await setAbortableTimeout(signal, throttleEndTimeMillis);
  } catch (e) {
    if (measurementId) {
      logger.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);
      return { appId, measurementId };
    }
    throw e;
  }
  try {
    const response = await fetchDynamicConfig(appFields);
    retryData.deleteThrottleMetadata(appId);
    return response;
  } catch (e) {
    const error = e;
    if (!isRetriableError(error)) {
      retryData.deleteThrottleMetadata(appId);
      if (measurementId) {
        logger.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);
        return { appId, measurementId };
      } else {
        throw e;
      }
    }
    const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
    const throttleMetadata = {
      throttleEndTimeMillis: Date.now() + backoffMillis,
      backoffCount: backoffCount + 1
    };
    retryData.setThrottleMetadata(appId, throttleMetadata);
    logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);
    return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);
  }
}
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise((resolve, reject) => {
    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    const timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(() => {
      clearTimeout(timeout);
      reject(ERROR_FACTORY.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  const httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var AnalyticsAbortSignal = class {
  constructor() {
    this.listeners = [];
  }
  addEventListener(listener) {
    this.listeners.push(listener);
  }
  abort() {
    this.listeners.forEach((listener) => listener());
  }
};
var defaultEventParametersForInit;
async function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {
  if (options && options.global) {
    gtagFunction("event", eventName, eventParams);
    return;
  } else {
    const measurementId = await initializationPromise;
    const params = Object.assign(Object.assign({}, eventParams), { "send_to": measurementId });
    gtagFunction("event", eventName, params);
  }
}
async function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {
  if (options && options.global) {
    gtagFunction("set", { "screen_name": screenName });
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise;
    gtagFunction("config", measurementId, {
      update: true,
      "screen_name": screenName
    });
  }
}
async function setUserId$1(gtagFunction, initializationPromise, id, options) {
  if (options && options.global) {
    gtagFunction("set", { "user_id": id });
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise;
    gtagFunction("config", measurementId, {
      update: true,
      "user_id": id
    });
  }
}
async function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {
  if (options && options.global) {
    const flatProperties = {};
    for (const key of Object.keys(properties)) {
      flatProperties[`user_properties.${key}`] = properties[key];
    }
    gtagFunction("set", flatProperties);
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise;
    gtagFunction("config", measurementId, {
      update: true,
      "user_properties": properties
    });
  }
}
async function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {
  const measurementId = await initializationPromise;
  return new Promise((resolve, reject) => {
    gtagFunction("get", measurementId, "client_id", (clientId) => {
      if (!clientId) {
        reject(ERROR_FACTORY.create(
          "no-client-id"
          /* AnalyticsError.NO_CLIENT_ID */
        ));
      }
      resolve(clientId);
    });
  });
}
async function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {
  const measurementId = await initializationPromise;
  window[`ga-disable-${measurementId}`] = !enabled;
}
var defaultConsentSettingsForInit;
function _setConsentDefaultForInit(consentSettings) {
  defaultConsentSettingsForInit = consentSettings;
}
function _setDefaultEventParametersForInit(customParams) {
  defaultEventParametersForInit = customParams;
}
async function validateIndexedDB() {
  if (!isIndexedDBAvailable()) {
    logger.warn(ERROR_FACTORY.create("indexeddb-unavailable", {
      errorInfo: "IndexedDB is not available in this environment."
    }).message);
    return false;
  } else {
    try {
      await validateIndexedDBOpenable();
    } catch (e) {
      logger.warn(ERROR_FACTORY.create("indexeddb-unavailable", {
        errorInfo: e === null || e === void 0 ? void 0 : e.toString()
      }).message);
      return false;
    }
  }
  return true;
}
async function _initializeAnalytics(app, dynamicConfigPromisesList2, measurementIdToAppId2, installations, gtagCore, dataLayerName2, options) {
  var _a;
  const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
  dynamicConfigPromise.then((config) => {
    measurementIdToAppId2[config.measurementId] = config.appId;
    if (app.options.measurementId && config.measurementId !== app.options.measurementId) {
      logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId}) does not match the measurement ID fetched from the server (${config.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`);
    }
  }).catch((e) => logger.error(e));
  dynamicConfigPromisesList2.push(dynamicConfigPromise);
  const fidPromise = validateIndexedDB().then((envIsValid) => {
    if (envIsValid) {
      return installations.getId();
    } else {
      return void 0;
    }
  });
  const [dynamicConfig, fid] = await Promise.all([
    dynamicConfigPromise,
    fidPromise
  ]);
  if (!findGtagScriptOnPage(dataLayerName2)) {
    insertScriptTag(dataLayerName2, dynamicConfig.measurementId);
  }
  if (defaultConsentSettingsForInit) {
    gtagCore("consent", "default", defaultConsentSettingsForInit);
    _setConsentDefaultForInit(void 0);
  }
  gtagCore("js", /* @__PURE__ */ new Date());
  const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};
  configProperties[ORIGIN_KEY] = "firebase";
  configProperties.update = true;
  if (fid != null) {
    configProperties[GA_FID_KEY] = fid;
  }
  gtagCore("config", dynamicConfig.measurementId, configProperties);
  if (defaultEventParametersForInit) {
    gtagCore("set", defaultEventParametersForInit);
    _setDefaultEventParametersForInit(void 0);
  }
  return dynamicConfig.measurementId;
}
var AnalyticsService = class {
  constructor(app) {
    this.app = app;
  }
  _delete() {
    delete initializationPromisesMap[this.app.options.appId];
    return Promise.resolve();
  }
};
var initializationPromisesMap = {};
var dynamicConfigPromisesList = [];
var measurementIdToAppId = {};
var dataLayerName = "dataLayer";
var gtagName = "gtag";
var gtagCoreFunction;
var wrappedGtagFunction;
var globalInitDone = false;
function settings(options) {
  if (globalInitDone) {
    throw ERROR_FACTORY.create(
      "already-initialized"
      /* AnalyticsError.ALREADY_INITIALIZED */
    );
  }
  if (options.dataLayerName) {
    dataLayerName = options.dataLayerName;
  }
  if (options.gtagName) {
    gtagName = options.gtagName;
  }
}
function warnOnBrowserContextMismatch() {
  const mismatchedEnvMessages = [];
  if (isBrowserExtension()) {
    mismatchedEnvMessages.push("This is a browser extension environment.");
  }
  if (!areCookiesEnabled()) {
    mismatchedEnvMessages.push("Cookies are not available.");
  }
  if (mismatchedEnvMessages.length > 0) {
    const details = mismatchedEnvMessages.map((message, index) => `(${index + 1}) ${message}`).join(" ");
    const err = ERROR_FACTORY.create("invalid-analytics-context", {
      errorInfo: details
    });
    logger.warn(err.message);
  }
}
function factory(app, installations, options) {
  warnOnBrowserContextMismatch();
  const appId = app.options.appId;
  if (!appId) {
    throw ERROR_FACTORY.create(
      "no-app-id"
      /* AnalyticsError.NO_APP_ID */
    );
  }
  if (!app.options.apiKey) {
    if (app.options.measurementId) {
      logger.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);
    } else {
      throw ERROR_FACTORY.create(
        "no-api-key"
        /* AnalyticsError.NO_API_KEY */
      );
    }
  }
  if (initializationPromisesMap[appId] != null) {
    throw ERROR_FACTORY.create("already-exists", {
      id: appId
    });
  }
  if (!globalInitDone) {
    getOrCreateDataLayer(dataLayerName);
    const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);
    wrappedGtagFunction = wrappedGtag;
    gtagCoreFunction = gtagCore;
    globalInitDone = true;
  }
  initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);
  const analyticsInstance = new AnalyticsService(app);
  return analyticsInstance;
}
function getAnalytics(app = getApp()) {
  app = getModularInstance(app);
  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
  if (analyticsProvider.isInitialized()) {
    return analyticsProvider.getImmediate();
  }
  return initializeAnalytics(app);
}
function initializeAnalytics(app, options = {}) {
  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
  if (analyticsProvider.isInitialized()) {
    const existingInstance = analyticsProvider.getImmediate();
    if (deepEqual(options, analyticsProvider.getOptions())) {
      return existingInstance;
    } else {
      throw ERROR_FACTORY.create(
        "already-initialized"
        /* AnalyticsError.ALREADY_INITIALIZED */
      );
    }
  }
  const analyticsInstance = analyticsProvider.initialize({ options });
  return analyticsInstance;
}
async function isSupported() {
  if (isBrowserExtension()) {
    return false;
  }
  if (!areCookiesEnabled()) {
    return false;
  }
  if (!isIndexedDBAvailable()) {
    return false;
  }
  try {
    const isDBOpenable = await validateIndexedDBOpenable();
    return isDBOpenable;
  } catch (error) {
    return false;
  }
}
function setCurrentScreen(analyticsInstance, screenName, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch((e) => logger.error(e));
}
async function getGoogleAnalyticsClientId(analyticsInstance) {
  analyticsInstance = getModularInstance(analyticsInstance);
  return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);
}
function setUserId(analyticsInstance, id, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch((e) => logger.error(e));
}
function setUserProperties(analyticsInstance, properties, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch((e) => logger.error(e));
}
function setAnalyticsCollectionEnabled(analyticsInstance, enabled) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch((e) => logger.error(e));
}
function setDefaultEventParameters(customParams) {
  if (wrappedGtagFunction) {
    wrappedGtagFunction("set", customParams);
  } else {
    _setDefaultEventParametersForInit(customParams);
  }
}
function logEvent(analyticsInstance, eventName, eventParams, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch((e) => logger.error(e));
}
function setConsent(consentSettings) {
  if (wrappedGtagFunction) {
    wrappedGtagFunction("consent", "update", consentSettings);
  } else {
    _setConsentDefaultForInit(consentSettings);
  }
}
var name = "@firebase/analytics";
var version = "0.10.6";
function registerAnalytics() {
  _registerComponent(new Component(
    ANALYTICS_TYPE,
    (container, { options: analyticsOptions }) => {
      const app = container.getProvider("app").getImmediate();
      const installations = container.getProvider("installations-internal").getImmediate();
      return factory(app, installations, analyticsOptions);
    },
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ));
  _registerComponent(new Component(
    "analytics-internal",
    internalFactory,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  registerVersion(name, version);
  registerVersion(name, version, "esm2017");
  function internalFactory(container) {
    try {
      const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
      return {
        logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)
      };
    } catch (e) {
      throw ERROR_FACTORY.create("interop-component-reg-failed", {
        reason: e
      });
    }
  }
}
registerAnalytics();
export {
  getAnalytics,
  getGoogleAnalyticsClientId,
  initializeAnalytics,
  isSupported,
  logEvent,
  setAnalyticsCollectionEnabled,
  setConsent,
  setCurrentScreen,
  setDefaultEventParameters,
  setUserId,
  setUserProperties,
  settings
};
/*! Bundled license information:

safevalues/dist/mjs/environment/dev.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/secrets.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/attribute_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/string_literal.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/sensitive_attributes.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/attribute_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/trusted_types.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/html_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/document_fragment_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/resource_url_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/script_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/pure.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/url_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/range.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/inert_fragment.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/no_clobber.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/resource_url_policy.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/sanitizer_table.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/default_sanitizer_table.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/html_sanitizer.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/html_sanitizer_builder.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/resource_url_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/script_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/style_sheet_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/style_sheet_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/index.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/anchor.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/area.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/base.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/button.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/element.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/embed.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/form.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/iframe.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/input.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/link.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/object.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/window.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/script.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/style.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/svg.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/svg_use.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/document.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/dom_parser.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/fetch.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/global.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/location.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/service_worker_container.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/url.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/worker.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/index.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

@firebase/analytics/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase_analytics.js.map
